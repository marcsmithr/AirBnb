{"ast":null,"code":"import _regeneratorRuntime from\"/home/marc/exercise/projects/airbnb/frontend/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";import _asyncToGenerator from\"/home/marc/exercise/projects/airbnb/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";// frontend/src/store/csrf.js\nimport Cookies from'js-cookie';export function csrfFetch(_x){return _csrfFetch.apply(this,arguments);}function _csrfFetch(){_csrfFetch=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(url){var options,res,_args=arguments;return _regeneratorRuntime().wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:options=_args.length>1&&_args[1]!==undefined?_args[1]:{};// set options.method to 'GET' if there is no method\noptions.method=options.method||'GET';// set options.headers to an empty object if there is no headers\noptions.headers=options.headers||{};// if the options.method is not 'GET', then set the \"Content-Type\" header to\n// \"application/json\", and set the \"XSRF-TOKEN\" header to the value of the\n// \"XSRF-TOKEN\" cookie\nif(options.method.toUpperCase()!=='GET'){options.headers['Content-Type']=options.headers['Content-Type']||'application/json';options.headers['XSRF-Token']=Cookies.get('XSRF-TOKEN');}// call the default window's fetch with the url and the options passed in\n_context.next=6;return window.fetch(url,options);case 6:res=_context.sent;if(!(res.status>=400)){_context.next=9;break;}throw res;case 9:return _context.abrupt(\"return\",res);case 10:case\"end\":return _context.stop();}}},_callee);}));return _csrfFetch.apply(this,arguments);}export function restoreCSRF(){return csrfFetch('/api/csrf/restore');}","map":{"version":3,"names":["Cookies","csrfFetch","url","options","method","headers","toUpperCase","get","window","fetch","res","status","restoreCSRF"],"sources":["/home/marc/exercise/projects/airbnb/frontend/src/store/csrf.js"],"sourcesContent":["// frontend/src/store/csrf.js\nimport Cookies from 'js-cookie';\n\nexport async function csrfFetch(url, options = {}) {\n  // set options.method to 'GET' if there is no method\n  options.method = options.method || 'GET';\n  // set options.headers to an empty object if there is no headers\n  options.headers = options.headers || {};\n\n  // if the options.method is not 'GET', then set the \"Content-Type\" header to\n    // \"application/json\", and set the \"XSRF-TOKEN\" header to the value of the\n    // \"XSRF-TOKEN\" cookie\n  if (options.method.toUpperCase() !== 'GET') {\n    options.headers['Content-Type'] =\n      options.headers['Content-Type'] || 'application/json';\n    options.headers['XSRF-Token'] = Cookies.get('XSRF-TOKEN');\n  }\n  // call the default window's fetch with the url and the options passed in\n  const res = await window.fetch(url, options);\n\n  // if the response status code is 400 or above, then throw an error with the\n    // error being the response\n  if (res.status >= 400) throw res;\n\n  // if the response status code is under 400, then return the response to the\n    // next promise chain\n  return res;\n}\n\nexport function restoreCSRF() {\n    return csrfFetch('/api/csrf/restore');\n  }\n\n"],"mappings":"oRAAA;AACA,MAAOA,QAAO,KAAM,WAAW,CAE/B,eAAsBC,UAAS,8CAwB9B,2FAxBM,iBAAyBC,GAAG,oJAAEC,OAAO,+CAAG,CAAC,CAAC,CAC/C;AACAA,OAAO,CAACC,MAAM,CAAGD,OAAO,CAACC,MAAM,EAAI,KAAK,CACxC;AACAD,OAAO,CAACE,OAAO,CAAGF,OAAO,CAACE,OAAO,EAAI,CAAC,CAAC,CAEvC;AACE;AACA;AACF,GAAIF,OAAO,CAACC,MAAM,CAACE,WAAW,EAAE,GAAK,KAAK,CAAE,CAC1CH,OAAO,CAACE,OAAO,CAAC,cAAc,CAAC,CAC7BF,OAAO,CAACE,OAAO,CAAC,cAAc,CAAC,EAAI,kBAAkB,CACvDF,OAAO,CAACE,OAAO,CAAC,YAAY,CAAC,CAAGL,OAAO,CAACO,GAAG,CAAC,YAAY,CAAC,CAC3D,CACA;AAAA,sBACkBC,OAAM,CAACC,KAAK,CAACP,GAAG,CAAEC,OAAO,CAAC,QAAtCO,GAAG,oBAILA,GAAG,CAACC,MAAM,EAAI,GAAG,+BAAQD,IAAG,wCAIzBA,GAAG,yDACX,4CAED,MAAO,SAASE,YAAW,EAAG,CAC1B,MAAOX,UAAS,CAAC,mBAAmB,CAAC,CACvC"},"metadata":{},"sourceType":"module","externalDependencies":[]}